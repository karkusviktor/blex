#!/system/bin/sh
# My Charging Controller
# mcc Main (201807211)
# JayminSuthar @ xda-developers

# Copyright (c) 2018 Jaymin Suthar. All rights reserved.

# This file is a part of "My Charging Controller (mcc)".

# mcc is released under the terms of the GNU GPL v3, as been
## published by the Free Software Foundation. And permission
## hereby is granted to use, modify or redistribute it maybe
## partially or entirely under GPLv3 only.

# mcc was written in a hope of being useful. And any kind of
## warranty is not provided. See GPLv3 for details.

# You should already have received a copy of GPLv3 with mcc,
## if not, see <http://www.gnu.org/licenses/>.

mcc_dir=/data/adb/mcc;
log_dir=$mcc_dir/log;
bin_dir=$mcc_dir/bin;
doc_dir=$mcc_dir/docs;
cfg_path=$mcc_dir/mcc.conf;
help_path=$doc_dir/README.md;

abort() {

  echo ' ';
  print --error "$1";
  exit;
}

print() {

  case "$1" in
    --error) echo "FATAL ERROR: $1"; ;;
    --warn)  echo "WARNING: $1";     ;;
    *)       echo "INFO: $1";        ;;
  esac;
}

if (! id | grep uid=0 >/dev/null); then

  su -c mcc "$@";
  exit;
fi;

if ([ ! -d $mcc_dir ] || [ ! -x $bin_dir/busybox ]); then
  abort 'There was an internal error';
fi;

if [ -z "$skip_mcc_detach" ]; then

  skip_mcc_detach=true mcc "$@" &
  exit;

elif [ -z "$disable_mcc_logs" ]; then

  if [ -z "$skip_mcc_errors" ]; then

    skip_mcc_errors=true mcc "$@" 2>$log_dir/main_err.log;
    exit;

  else
    set -x 2>$log_dir/main.log;
  fi;
fi;

export PATH=$bin_dir:$PATH;

get_prop() {

  if [ ! -f "$2" ]; then
    local prop_path=$cfg_path;
  else
    local prop_path="$2";
  fi

  sed -n "s/^$1=//p" $prop_path;
}

set_prop() {
  sed -i "s|^$1=|$1=$2|" $cfg_path;
}

auto_switch() {
  get_prop auto_switch;
}

auto_power() {
  get_prop auto_power;
}

thr_disable() {
  get_prop thr_disable;
}

thr_enable() {
  get_prop thr_enable;
}

thr_power() {
  get_prop thr_power;
}

daemon_do() {
  get_prop daemon_do;
}

uevent_f() {
  get_prop uevent;
}

batt_level() {
  get_prop POWER_SUPPLY_CAPACITY $(uevent_f);
}

is_charging() {

  if [ "$1" == --ck-current ]; then
    test $(get_prop POWER_SUPPLY_CURRENT_NOW $(uevent_f)) -le 0;
  else
    grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $(uevent_f);
  fi;
}

is_runningd() {
  ps | grep -v grep | grep '{mcc}' | grep '\-\-launch\-daemon$' | grep -vq $$;
}

is_belonging() {

  if ([ $1 -le $2 ] || [ $1 -ge $3 ]); then
    abort "$1 does not belong to $2-$3";
  fi;
}

is_bounded() {
  is_belonging $1 0 100;
}

is_level() {

  if [ ! $1 -eq $1 2>/dev/null ]; then
    abort "$1 is not a valid number";

  else
    is_bounded $1;
  fi;
}

write_() {

  local i;
  local path;
  local key_on;
  local key_off;

  for i in 1 2; do

    path="$(switch_ $i)";
    key_on=$(echo "$path" | awk '{ print $2 }');
    key_off=$(echo "$path" | awk '{ print $3 }');
    path=$(echo "$path" | awk '{ print $1 }');

    if [ -z $key_on ]; then break; fi;

    case $1 in
      OFF) echo $key_off >$switch; ;;
      ON)  echo $key_on  >$switch; ;;
    esac;
  done;
}

switch_() {

  if [ ! $1 -eq $1 2>/dev/null ]; then

    case $1 in
      ON)
        local inv_stat=OFF;
        local test='! is_charging';
      ;;

      OFF)
        local inv_stat=ON;
        local test='is_charging';
      ;;
    esac;
        
    if (eval $test); then
      switched=false;

    elif (! $switched && eval "$test --ck-current"); then

      switched=false;
      write_ $inv_stat;
      sleep 0.3;

    else
      switched=true;
    fi;

    if (! $switched); then write_ $1; fi;

  else
    get_prop switch_$1;
  fi;
}

toggle() {

  local val_new;
  local stat_new;

  if ($($1)); then

    val_new=false;
    stat_new=OFF;

  else
    val_new=true;
    stat_new=ON;
  fi;

  set_prop $1 $val_new;

  print "$2 has been toggled $stat_new";
}

charge() {

  case $1 in
    --enable)
      local key_init=enable;
      local text=enabled;
    ;;

    --disable)
      local key_init=disable;
      local text=disabled;
    ;;
  esac;

  if [ $(daemon_do) != default ]; then
    abort 'Another mcc process is already running';
  fi;

  if (echo $2 | grep -Eq '^[0-9]+%$'); then

    local dest_level=$(echo $2 | tr -d %);
    is_bounded $dest_level;

    print "Charging $text until ${dest_level}%";

    set_prop daemon_do $key_init;
    while [ $(batt_level) -ne $dest_level ]; do sleep 1; done;

  elif (echo $2 | grep -Eq '^[0-9]+[smh]?$'); then

    set_prop daemon_do $key_init;

    print "Charging $text for $2";

    sleep $2;

  else
    abort "Invalid format: $2";
  fi;

  set_prop daemon_do default;
  echo '- Done';
}

reconfigure() {

  local i;
  local tmp;
  local key_on;
  local key_off;
  local sock_path;
  local sock_info;
  local chg_events;
  local main_events;
  local cache_path=$mcc_dir/tmp.cache;

  if [ ! -f /data/adb/mcc_skip_root ]; then
    local skip_root=false;
  else
    local skip_root=true;
  fi;

  if [ "$1" != --force ]; then

    if ([ -f $(uevent_f) ] && [ -f $(switch_ 1) ]); then
      return 0;
    elif [ "$1" == --no-action ]; then
      return 1;
    fi;
  fi;

  for i in 1 2; do set_prop switch_$i dummySwitch; done;

  print 'Reconfiguring (low_level)...';

  find /sys/devices /sys/module -type f -name uevent >$cache_path;

  i=1;

  while read -r main_events; do

    if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*' $main_events); then

      set_prop uevent $main_events;

      while read -r chg_events; do

        if (grep -Eq '^POWER_SUPPLY_NAME=.*([Bb]att|USB|usb)' $chg_events || \
            grep -Eq '^DRIVER=.*[Cc]harg(er|ing)' $chg_events); then

          for sock_path in ${chg_events%/*}/*; do

            sock_info="$(ls -l $sock_path)";

            if (echo "$sock_info" | grep -Eq '^\-[rx\-]+w[rwx\-]* '             && \
                (! $skip_root || echo "$sock_info" | grep -Eq ' system | radio ')); then

              case "$(cat $sock_path)" in

                1)        key_on=1;        key_off=0;        ;;
                0)        key_on=0;        key_off=1;        ;;
                on)       key_on=on;       key_off=off;      ;;
                off)      key_on=off;      key_off=on;       ;;
                true)     key_on=true;     key_off=false;    ;;
                false)    key_on=false;    key_off=true;     ;;
                enable)   key_on=enable;   key_off=disable;  ;;
                disable)  key_on=disable;  key_off=enable;   ;;
                enabled)  key_on=enabled;  key_off=disabled; ;;
                disabled) key_on=disabled; key_off=enabled;  ;;
                *) continue; ;;
              esac;

              echo $key_off >$sock_path;
              sleep 0.3;

              if (is_charging); then

                tmp=$key_on;
                key_on=$key_off;
                key_off=$tmp;

                echo $key_off >$sock_path;
                sleep 0.3;
              fi;

              if (! is_charging); then

                echo $key_on >$sock_path;
                sleep 0.3;

                if (is_charging); then

                  set_prop switch_$i "$sock_path $key_on $key_off";

                  if [ $i -eq 2 ]; then
                    break 3;
                  else
                    i=2;
                  fi;
                fi;
              fi;
            fi;
          done;
          if [ $i -eq 2 ]; then break 2; fi;
        fi;
      done <$cache_path;
    fi;
  done <$cache_path;

  rm $cache_path;

  if [ $i -gt 1 ]; then

    echo '- Done';
    print --warn 'A reboot is recommended for now';

  else
    set_prop uevent dummyEvents;
    abort 'Failed to reconfigure it';
  fi;
  return 0;
}

if [ "$1" == --force ]; then

  if ([ "$2" != --switch ] && [ "$2" != --power ]); then
    abort 'Invalid arguments';
  fi;
  enforce=true;
  shift;

else
  enforce=false;
fi;

case $1 in
  --switch)

    if [ $# -eq 2 ]; then

      is_level "$2";
      thr_disable=$2;

      if (! $enforce); then is_belonging $thr_disable 20 85; fi;

      if [ $thr_disable -ge 25 ]; then
        thr_enable=$((thr_disable - 10));

      elif [ $thr_disable -ge 20 ]; then
        thr_enable=15;

      elif [ $thr_disable -ge 6 ]; then
        thr_enable=$((thr_disable - 5));

      elif [ $thr_disable -eq 1 ]; then
        thr_disable=2;
        thr_enable=1;

      else
        thr_enable=1;
      fi;

    elif [ $# -eq 3 ]; then

      is_level "$2";
      is_level "$3";

      if [ $2 -le $3 ]; then
        abort "$2 is not > $3";

      elif (! $enforce); then

        is_belonging $2 15 85;
        is_belonging $3 15 85;

        if [ $2 -lt $(($3+ 5)) ]; then abort "$2 is too close to $3"; fi;
      fi;

    else
      abort 'Invalid arguments';
    fi;

    set_prop thr_disable ${thr_disable}$2;
    set_prop thr_enable  ${thr_enable}$3;

    print 'Auto Switch thresholds have been updated';
  ;;

  --power)

    if [ $# -ne 2 ]; then abort 'Invalid arguments'; fi;

    is_level "$2";

    if (! $enforce); then is_belonging $2 5 20; fi;

    set_prop thr_power $2;

    print 'Auto Power threshold has been updated';
  ;;

  --revert)
  
    if [ $# -gt 1 ]; then abort 'Invalid arguments'; fi;

    set_prop thr_disable 80;
    set_prop thr_enable  70;
    set_prop thr_power   20;

    print 'Auto (daemon) Thresholds have been reverted';
  ;;

  --toggle)
    shift;

    case $1 in
      --switch)

        if (! $(auto_switch)); then reconfigure; fi;
        toggle auto_switch 'Auto Switch';
      ;;

      --power)

        if (! $(auto_power)); then reconfigure; fi;
        toggle auto_power 'Auto Power';
      ;;

      --revert)
        reconfigure;

        set_prop auto_switch true;
        set_prop auto_power  true;

        print 'Auto (daemon) Togglers have been reverted';
      ;;

      *) abort 'Invalid arguments'; ;;
    esac;
  ;;

  --enable)
    
    if [ $# -ne 2 ]; then abort 'Invalid arguments'; fi;
    charge --enable $2;
  ;;

  --disable)

    if [ $# -ne 2 ]; then abort 'Invalid arguments'; fi;
    charge --disable $2;
  ;;

  --cleanup)

    for pid in $(ps | grep -v grep | grep '{mcc}' | grep -v $$ | awk '{ print $1 }'); do
      kill -9 $pid;
    done;

    rm -f $mcc_dir/lock;

    set_prop daemon_do default;

    print 'Cleanup done';
  ;;

  --redaemon)

    if (is_runningd); then
      abort 'mcc daemon is already running';

    elif (! $(auto_switch) && ! $(auto_power)); then
      abort 'Auto Togglers are both OFF';
    fi;

    reconfigure;
    disable_mcc_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1;

    if (! is_runningd); then
      abort 'Failed to re-launch the daemon';
    else
      print 'mcc daemon has been resumed';
    fi;
  ;;

  --launch-daemon)

    switched=false;
    last_stat=default;

    while (:); do

      while (! reconfigure --no-action || [ -f $mcc_dir/lock ]); do
        sleep 0.1;
      done;

      case $(daemon_do) in
        default)

          if ($(auto_switch)); then

            if [ $(batt_level) -ge $(thr_disable) ]; then

              last_stat=OFF;
              switch_ OFF;

            elif [ $(batt_level) -le $(thr_enable) ]; then

              last_stat=ON;
              switch_ ON;

            elif [ $last_stat != default ]; then

              switch_ $last_stat;
              if ($switched); then last_stat=default; fi;
            fi;
          fi;
        ;;

        disable) switch_ OFF; ;;
        enable)  switch_ ON;  ;;
      esac;

      if ($(auto_power)); then

        if [ $(batt_level) -le $(thr_power) ]; then
          if (! poweroff); then setprop sys.powerctl shutdown; fi;
        fi;
      fi;

      sleep 1;
    done;
  ;;

  --restat)

    dumpsys batterystats --reset >/dev/null;
    rm -f /data/system/batterystats.bin;

    print 'Batterystats have been reset';
  ;;

  --reconfig) reconfigure --force; ;;

  --reset)

    disable_mcc_logs=true mcc --restat;
    reconfigure --force;
  ;;

  --info)
    reconfigure;

    if (! is_charging); then
      chg_stat='Not charging';
    else
      chg_stat=Charging;
    fi;

    if (! $(auto_switch)); then
      sw_stat=OFF;
    else
      sw_stat=ON;
    fi;

    if (! $(auto_power)); then
      pw_stat=OFF;
    else
      pw_stat=ON;
    fi;

    if (! is_runningd); then
      dm_stat='Not running';
    else
      dm_stat=Running;
    fi;

    echo -e 'Battery Information\n';

    echo "- Level : $(batt_level)";
    echo "- Health: $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))";
    echo -e "- Status: $chg_stat\n";

    echo -e 'Current Settings\n';

    echo "- Auto Switch thresholds: $(thr_disable), $(thr_enable)";
    echo "- Auto Power  threshold : $(thr_power)";

    echo "- Auto Switch status: $sw_stat";
    echo -e "- Auto Power status : $pw_stat\n";

    echo -e "Daemon Status: $dm_stat\n";
  ;;

  --help)

    head -n 5  $help_path;
    head -n 61 $help_path | tail -n 40;
  ;;

  *) abort 'Invalid arguments'; ;;
esac;
