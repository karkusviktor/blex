#!/system/bin/sh
# My Charging Controller
# JayminSuthar @ xda-developers

# Copyright (c) 2018 Jaymin Suthar. All rights reserved.

# This file is a part of "My Charging Controller (mcc)".

# mcc is released under the terms of the GNU GPL v3, as been
## published by the Free Software Foundation. And permission
## hereby is granted to use, modify or redistribute it maybe
## partially or entirely under GPLv3 only.

# mcc was written in a hope of being useful. And any kind of
## warranty is not provided. See GPLv3 for details.

# You should already have received a copy of GPLv3 with mcc,
## if not, see <http://www.gnu.org/licenses/>.

enforce=false
mcc_dir=/data/adb/mcc
bin_dir=$mcc_dir/bin
sr_path=$mcc_dir/.running
cfg_path=$mcc_dir/mcc.conf
help_path=$mcc_dir/docs/README.md

abort() {
  echo ' '
  print --error "$1"
  exit
}

print() {
  case "$1" in
    --done)  echo '- Done'      ;;
    --error) echo "ERROR: $2"   ;;
    --warn)  echo "WARNING: $2" ;;
    --info)  echo "INFO: $2"    ;;
    *)       echo "- $1"        ;;
  esac
}

if ! id | grep uid=0 >/dev/null; then
  abort 'Run `su` first and then mcc'
elif test ! -d $mcc_dir || test ! -x $bin_dir/awk; then
  abort 'There was an internal error'
elif test -f $mcc_dir/.lock; then
  echo
  print --error "Due to some safety reasons, you can't execute mcc for"
  print --error '120 seconds after booting, wait softly until then.'
  exit
fi

if test -z "$skip_mcc_detach"; then
  ( (skip_mcc_detach=true mcc "$@") &)
  exit
elif test -z "$skip_mcc_logs"; then
  exec 2>$mcc_dir/log/main.log
  set -x
fi
export PATH=$bin_dir:$PATH

get_prop() {
  sed -n "s/^$1=//p" $(ls $2 || echo $cfg_path)
}

get_event() {
  get_prop POWER_SUPPLY_$1 $(uevent_f)
}

set_prop() {
  sed -i "s|^$1=.*|$1=$2|" $cfg_path
}

auto_switch() {
  get_prop auto_switch
}

auto_power() {
  get_prop auto_power
}

thr_disable() {
  get_prop thr_disable
}

thr_enable() {
  get_prop thr_enable
}

thr_power() {
  get_prop thr_power
}

switch_do() {
  get_prop switch_do
}

uevent_f() {
  get_prop uevent
}

switch_p() {
  f=1
  case "$2" in
    --on)  f=2 ;;
    --off) f=3 ;;
  esac
  get_prop switch_$1 | awk "{ print \$$f }"
}

batt_level() {
  get_event CAPACITY
}

is_charging() {
  if test "$1" != --ck-current; then
    get_event STATUS | grep -q '^[Cc]harging$'
  else
    test $(get_event CURRENT_NOW) -le 0
  fi
}

is_belonging() {
  if test $1 -lt $2 || test $1 -gt $3; then
    abort "$1 does not belong to $2-$3"
  fi
}

is_level() {
  if ! echo $1 | grep -Eq '^[0-9]+$'; then abort "$1 is not a number"; fi
  is_belonging $1 1 99
}

is_runningd() {
  ps | grep -v grep | grep '{mcc}' | grep '\-\-launch\-daemon$' | grep -vq $$
}

write_() {
  for i in 1 2; do
    if sw_path=$(switch_p $i | grep -v '^dummySwitch$'); then
      case $1 in
        ON)  switch_p $i --on  >$sw_path ;;
        OFF) switch_p $i --off >$sw_path ;;
      esac
    fi
  done
}

switch_() {
  case $1 in
    ON)
      inv_stat=OFF
      test='! is_charging'
    ;;
    OFF)
      inv_stat=ON
      test='is_charging'
    ;;
  esac

  if eval $test; then
    switch=true
  elif $switch && eval "$test --ck-current"; then
    write_ $inv_stat
    sleep 0.3
  else
    switch=false
  fi
  if $switch; then write_ $1; fi
}

toggle() {
  print 'Checking in configs'
  if $($1); then
    val_new=false
    stat_new=OFF
  else
    val_new=true
    stat_new=ON

    if ! is_runningd; then
      abort 'The mcc daemon is not running'
    elif ! reconfigure; then
      abort 'Low level configuration failed'
    fi
  fi
  print "Toggling $2 $stat_new"
  set_prop $1 $val_new
  print --done
}

charge() {
  case $1 in
    --enable)  key_init=enable  ;;
    --disable) key_init=disable ;;
  esac
  text=${key_init}d

  if ! is_runningd; then
    abort 'The mcc daemon is not running'
  elif test $(switch_do) != default; then
    abort 'Another task is already running'
  elif ! reconfigure; then
    abort 'Low level configuration failed'
  fi

  print --warn 'Manual methods are for advanced users only, without'
  print --warn 'the mathematics regarding battery life, remember it'
  print --warn '(the math) before operating on it.'

  print 'Parsing argument'
  if echo $2 | grep -Eq '^[0-9]+%$'; then
    print --info 'Level based method call detected.'

    end_level=$(echo $2 | tr -d %)
    is_belonging $end_level 1 99

    print 'Catching the mcc daemon'
    set_prop switch_do $key_init

    print "Holding it to keep charging $text until $2"
    print --info "Feel free to close the window, it'd run in background."
    while test $(batt_level) -ne $end_level; do sleep 1; done

  elif echo $2 | grep -Eq '^[0-9]+[smh]?$'; then
    print --info 'Time based method call detected.'

    print 'Catching the mcc daemon'
    set_prop switch_do $key_init

    print "Holding it to keep charging $text for $2"
    print --info "Feel free to close the window, it'd run in background."
    sleep $2

  else
    abort "Invalid format: $2"
  fi
  print 'Freeing the daemon'
  set_prop switch_do default
  print --done
}

reconfigure() {
  skip_root=false
  cache_path=$mcc_dir/tmp.cache

  if test "$1" != --force; then
    if test -f $(uevent_f) && test -f $(switch_p 1); then
      return 0
    elif test "$1" == --no-action; then
      return 1
    fi
  fi

  if test -f $sr_path; then
    print --info 'skip_root workaround enabled.'
    skip_root=true
  fi

  touch $sr_path
  for i in 1 2; do set_prop switch_$i dummySwitch; done

  print --warn 'Configurator requires the device to be charging, is'
  print --warn 'it charging right now ?? press enter when ready.'
  read i

  print 'Configuring mcc at kernel/driver level'

  find /sys/devices /sys/module -type f -name uevent >$cache_path

  i=1
  while read -r main_events; do
    if grep -q '^POWER_SUPPLY_NAME=.*[Bb]att' $main_events; then
      set_prop uevent $main_events

      while read -r chg_events; do
        if grep -Eq '^POWER_SUPPLY_NAME=.*([Bb]att|USB|usb)' $chg_events || \
           grep -Eq '^DRIVER=.*[Cc]harg(er|ing)'             $chg_events; then

          for sock_path in ${chg_events%/*}/*; do
            sock_info="$(ls -l $sock_path)"
            if   echo "$sock_info" | grep -Eq '^\-[rx\-]+w[rwx\-]* ' && \
(! $skip_root || echo "$sock_info" | grep -Eq ' system | radio '); then

              case "$(cat $sock_path)" in
                1)        key_on=1;        key_off=0;        ;;
                0)        key_on=0;        key_off=1;        ;;
                on)       key_on=on;       key_off=off;      ;;
                off)      key_on=off;      key_off=on;       ;;
                true)     key_on=true;     key_off=false;    ;;
                false)    key_on=false;    key_off=true;     ;;
                enable)   key_on=enable;   key_off=disable;  ;;
                disable)  key_on=disable;  key_off=enable;   ;;
                enabled)  key_on=enabled;  key_off=disabled; ;;
                disabled) key_on=disabled; key_off=enabled;  ;;
                *) continue ;;
              esac
              echo $key_off >$sock_path
              sleep 0.3

              if is_charging; then
                tmp=$key_on
                key_on=$key_off
                key_off=$tmp
                echo $key_off >$sock_path
                sleep 0.3
              fi

              if ! is_charging; then
                echo $key_on >$sock_path
                sleep 0.3
                if is_charging; then
                  set_prop switch_$i "$sock_path $key_on $key_off"
                  if test $i -eq 2; then break 3; fi
                  i=2
                fi
              fi
            fi
          done
          if test $i -eq 2; then break 2; fi
        fi
      done <$cache_path
    fi
  done <$cache_path
  rm $sr_path

  print --info 'Configurator manipulates kernel/driver files to detect'
  print --info 'required targets, which is bad if you got a weird OEM.'
  print --info 'I recommend a reboot just in case.'

  if test $i -eq 1; then
    set_prop uevent dummyEvents
    return 1
  fi
  print --done
  return 0
}

clear
echo '************************************************************'
echo '                My Charging Controller (mcc)                '
echo '************************************************************'
echo '   Copyright (c) 2018 Jaymin Suthar. All rights reserved.   '
echo '************************************************************'
echo

if test "$1" == --force; then
  if ! echo "$2" | grep -Eq '^(--switch|--power)$'; then
    abort 'Invalid argument(s)'
  fi
  print --warn 'Forcing thresholds outside set boundaries is unsafe'
  print --warn 'and all upto you. mcc did the math, but was skipped'
  print --warn 'by you.'
  enforce=true
  shift
fi

case $1 in
  --switch)

    if test $# -eq 2; then

      print 'Validating argument'
      is_level $2
      if ! $enforce; then is_belonging $2 20 85; fi

      print "Figuring out 'thr_enable'"
      if test $2 -ge 25; then
        thr_enable=$(($2 - 10))
      elif test $2 -ge 20; then
        thr_enable=15
      elif test $2 -ge 6; then
        thr_enable=$(($2 - 5))
      elif test $2 -eq 1; then
        thr_disable=2
        thr_enable=1
      else
        thr_enable=1
      fi

    elif test $# -eq 3; then

      print 'Validating arguments'

      is_level $2
      is_level $3

      if test $2 -le $3; then
        abort "$2 is not greater than $3"
      elif ! $enforce; then
        is_belonging $2 15 85
        is_belonging $3 15 85
        if test $2 -lt $(($3 + 5)); then abort "$2 is too close to $3"; fi
      fi
    else
      abort 'Invalid argument(s)'
    fi

    print "Updating 'thr_disable', 'thr_enable'"
    set_prop thr_disable $thr_disable $2
    set_prop thr_enable  $thr_enable  $3
    print --done
  ;;

  --power)
    if test $# -ne 2; then abort 'Invalid argument(s)'; fi

    print 'Validating argument'
    is_level $2
    if ! $enforce; then is_belonging $2 5 20; fi

    print "Updating 'thr_power'"
    set_prop thr_power $2
    print --done
  ;;

  --revert)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    print 'Reverting Automation thresholds'
    set_prop thr_disable 80
    set_prop thr_enable  70
    set_prop thr_power   20
    print --done
  ;;

  --toggle)
    shift
    case $1 in
      --switch) toggle auto_switch 'Auto Switch' ;;
      --power)  toggle auto_power  'Auto Power'  ;;

      --revert)

        if ! is_runningd; then
          abort 'The mcc daemon is not running'
        elif ! reconfigure; then
          abort 'Low level configuration failed'
        fi

        print 'Reverting Automation features'
        set_prop auto_switch true
        set_prop auto_power  true
        print --done
      ;;
      *) abort 'Invalid argument(s)' ;;
    esac
  ;;

  --enable)
    if test $# -ne 2; then abort 'Invalid argument(s)'; fi
    charge --enable $2
  ;;

  --disable)
    if test $# -ne 2; then abort 'Invalid argument(s)'; fi
    charge --disable $2
  ;;

  --cleanup)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    print --warn '[--cleanup] kills the mcc daemon, you must start it'
    print --warn 'again using [--ckdaemon] afterwards.'


    print 'Cleaning up'
    for pid in $(ps | grep -v grep | grep '{mcc}' | grep -v $$ | awk '{ print $1 }'); do
      kill -9 $pid
    done
    set_prop switch_do default
    print --done
  ;;

  --ckdaemon)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    if is_runningd; then
      abort 'The mcc daemon is already there'
    elif ! reconfigure; then
      abort 'Low level configuration failed'
    fi

    print 'Starting the mcc daemon'
    skip_mcc_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1
    sleep 0.1
    if ! is_runningd; then abort 'Starting the daemon failed'; fi
    print --done
  ;;

  --launch-daemon)
    switch=true
    revert=false
    stat_saved=default

    if test $# -gt 1; then abort 'Invalid argument(s)'; fi
    if is_runningd; then abort 'Another daemon instance already exists'; fi

    while true; do
      while ! reconfigure --no-action; do sleep 0.1; done

      if $(auto_power); then
        if test $(batt_level) -le $(thr_power); then
          if ! poweroff; then setprop sys.powerctl shutdown; fi
        fi
      fi
      case $(switch_do) in
        default)
          if $(auto_switch); then
            if test $(batt_level) -ge $(thr_disable); then
              revert=false
              stat_saved=OFF
              switch_ OFF

            elif test $(batt_level) -le $(thr_enable); then
              revert=false
              stat_saved=ON
              switch_ ON

            elif $revert; then
              if test $stat_saved != default; then
                switch_ $stat_saved
                if ! $switch; then revert=false; fi
              fi
            fi
          fi
        ;;
        disable)
          revert=true
          switch_ OFF
        ;;
        enable)
          revert=true
          switch_ ON
        ;;
      esac
      sleep 1
    done
  ;;

  --restat)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    print --warn '[--restat] might not work for all devices.'

    print 'Resetting batterystats'
    dumpsys batterystats --reset >/dev/null
    rm -f /data/system/batterystats.bin
    print --done
  ;;

  --config)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi
    if ! reconfigure --force; then abort 'Low level configuration failed'; fi
  ;;

  --reset)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    skip_mcc_logs=true skip_mcc_detach=true mcc --restat
    if ! reconfigure --force; then abort 'Low level configuration failed'; fi
    print --done
  ;;

  --info)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    if ! reconfigure; then abort 'Low level configuration failed'; fi
    if ! is_charging; then
      chg_stat='Not charging'
    else
      chg_stat=Charging
    fi
    if $(auto_switch); then
      as_stat=ON
    else
      as_stat=OFF
    fi
    if $(auto_power); then
      ap_stat=ON
    else
      ap_stat=OFF
    fi
    if ! is_runningd; then
      dm_stat='Not running'
    else
      dm_stat=Running
    fi

    echo -e 'Battery Information\n'

    echo "- Level : $(batt_level)"
    echo "- Health: $(get_event HEALTH)"
    echo -e "- Status: $chg_stat\n"

    echo -e 'Current Settings\n'

    echo "- Auto Switch thresholds: $(thr_disable), $(thr_enable)"
    echo "- Auto Power  threshold : $(thr_power)"
    echo "- Auto Switch status    : $as_stat"
    echo -e "- Auto Power status     : $ap_stat\n"

    echo -e "Daemon Status: $dm_stat\n"
  ;;

  --help)
    if test $# -gt 1; then abort 'Invalid argument(s)'; fi

    head -n 4   $help_path
    head -n 197 $help_path | tail -n 177
  ;;

  *)
    print --error 'No valid argument supplied, let mcc help a little'
    skip_mcc_logs=true mcc --help
  ;;
esac
