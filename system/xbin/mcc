#!/system/bin/sh
# My Charging Controller
# mcc Main (201807271)
# JayminSuthar @ xda-developers

# Copyright (c) 2018 Jaymin Suthar. All rights reserved.

# This file is a part of "My Charging Controller (mcc)".

# mcc is released under the terms of the GNU GPL v3, as been
## published by the Free Software Foundation. And permission
## hereby is granted to use, modify or redistribute it maybe
## partially or entirely under GPLv3 only.

# mcc was written in a hope of being useful. And any kind of
## warranty is not provided. See GPLv3 for details.

# You should already have received a copy of GPLv3 with mcc,
## if not, see <http://www.gnu.org/licenses/>.

mcc_dir=/data/adb/mcc;
log_dir=$mcc_dir/log;
bin_dir=$mcc_dir/bin;
doc_dir=$mcc_dir/docs;
cfg_path=$mcc_dir/mcc.conf;
lock_path=$mcc_dir/lock;
help_path=$doc_dir/README.md;

abort() {
  echo ' ';
  print --error "$1";
  exit;
}

print() {
  case "$1" in
    --error) echo "FATAL ERROR: $2"; ;;
    --warn)  echo "WARNING: $2";     ;;
    --done)  echo '- Done';          ;;
    *)       echo "INFO: $1";        ;;
  esac;
}

if (! id | grep uid=0 >/dev/null); then
  su -c mcc "$@";
  exit;
fi;
if ([ ! -d $mcc_dir ] || [ ! -x $bin_dir/busybox ]); then
  abort 'There was an internal error';
fi;
if [ -z "$skip_mcc_detach" ]; then
  skip_mcc_detach=true mcc "$@" &
  exit;
elif [ -z "$disable_mcc_logs" ]; then
  if [ -z "$skip_mcc_errors" ]; then
    skip_mcc_errors=true mcc "$@" 2>$log_dir/main_err.log;
    exit;
  else
    set -x 2>$log_dir/main.log;
  fi;
fi;

export PATH=$bin_dir:$PATH;

get_prop() {
  if [ ! -f "$2" ]; then
    prop_path=$cfg_path;
  else
    prop_path="$2";
  fi;
  sed -n "s/^$1=//p" $prop_path;
}

set_prop() {
  sed -i "s|^$1=.*|$1=$2|" $cfg_path;
}

auto_switch() {
  get_prop auto_switch;
}

auto_power() {
  get_prop auto_power;
}

thr_disable() {
  get_prop thr_disable;
}

thr_enable() {
  get_prop thr_enable;
}

thr_power() {
  get_prop thr_power;
}

switch_do() {
  get_prop switch_do;
}

uevent_f() {
  get_prop uevent;
}

batt_level() {
  get_prop POWER_SUPPLY_CAPACITY $(uevent_f);
}

is_charging() {
  if [ "$1" == --ck-current ]; then
    test $(get_prop POWER_SUPPLY_CURRENT_NOW $(uevent_f)) -le 0;
  else
    grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $(uevent_f);
  fi;
}

is_runningd() {
  ps | grep -v grep | grep '{mcc}' | grep '\-\-launch\-daemon$' | grep -vq $$;
}

is_belonging() {
  if ([ $1 -lt $2 ] || [ $1 -gt $3 ]); then
    abort "$1 does not belong to $2-$3";
  fi;
}

is_bounded() {
  is_belonging $1 1 99;
}

is_level() {
  if [ ! $1 -eq $1 ]; then
    abort "$1 is not a valid number";
  else
    is_bounded $1;
  fi;
}

write_() {

  for i in 1 2; do

    sw_path="$(switch_ $i)";
    key_on=$(echo "$sw_path" | awk '{ print $2 }');
    key_off=$(echo "$sw_path" | awk '{ print $3 }');
    sw_path=$(echo "$sw_path" | awk '{ print $1 }');

    if [ -z "$key_on" ]; then break; fi;
    case $1 in
      OFF) echo $key_off >$sw_path; ;;
      ON)  echo $key_on  >$sw_path; ;;
    esac;
  done;
}

switch_() {

  if [ ! $1 -eq $1 ]; then
    case $1 in
      ON)
        inv_stat=OFF;
        test='! is_charging';
      ;;
      OFF)
        inv_stat=ON;
        test='is_charging';
      ;;
    esac;

    if (eval $test); then
      switched=false;
    elif (! $switched && eval "$test --ck-current"); then
      write_ $inv_stat;
      sleep 0.3;
    else
      switched=true;
    fi;
    if (! $switched); then write_ $1; fi;

  else
    get_prop switch_$1;
  fi;
}

toggle() {
  if ($($1)); then
    val_new=false;
    stat_new=OFF;
  else
    val_new=true;
    stat_new=ON;
  fi;
  set_prop $1 $val_new;
  print "$2 has been toggled $stat_new";
}

charge() {
  case $1 in
    --enable)
      key_init=enable;
      text=enabled;
    ;;
    --disable)
      key_init=disable;
      text=disabled;
    ;;
  esac;

  if (! is_runningd); then
    abort 'The mcc daemon is not running';
  elif [ $(switch_do) != default ]; then
    abort 'Another mcc task is already running';
  fi;

  reconfigure;
  if (echo $2 | grep -Eq '^[0-9]+%$'); then

    dest_level=$(echo $2 | tr -d %);

    is_bounded $dest_level;
    print "Charging $text until ${dest_level}%";
    set_prop switch_do $key_init;
    while [ $(batt_level) -ne $dest_level ]; do sleep 1; done;

  elif (echo $2 | grep -Eq '^[0-9]+[smh]?$'); then

    set_prop switch_do $key_init;
    print "Charging $text for $2";
    sleep $2;

  else
    abort "Invalid format: $2";
  fi;
  set_prop switch_do default;
  print --done;
}

reconfigure() {
  local cache_path=$mcc_dir/tmp.cache;

  if [ ! -f /data/adb/mcc_skip_root ]; then
    skip_root=false;
  else
    skip_root=true;
  fi;

  if [ "$1" != --force ]; then
    if ([ -f $(uevent_f) ] && [ -f $(switch_ 1 | awk '{ print $1 }') ]); then
      return 0;
    elif [ "$1" == --no-action ]; then
      return 1;
    fi;
  fi;

  for i in 1 2; do set_prop switch_$i dummySwitch; done;

  print 'Reconfiguring (low_level)...';
  find /sys/devices /sys/module -type f -name uevent >$cache_path;

  i=1;
  while read -r main_events; do
    if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*' $main_events); then
      set_prop uevent $main_events;

      while read -r chg_events; do
        if (grep -Eq '^POWER_SUPPLY_NAME=.*([Bb]att|USB|usb)' $chg_events || \
            grep -Eq '^DRIVER=.*[Cc]harg(er|ing)' $chg_events); then

          for sock_path in ${chg_events%/*}/*; do
            sock_info="$(ls -l $sock_path)";
            if (echo "$sock_info" | grep -Eq '^\-[rx\-]+w[rwx\-]* '             && \
                (! $skip_root || echo "$sock_info" | grep -Eq ' system | radio ')); then

              case "$(cat $sock_path)" in
                1)        key_on=1;        key_off=0;        ;;
                0)        key_on=0;        key_off=1;        ;;
                on)       key_on=on;       key_off=off;      ;;
                off)      key_on=off;      key_off=on;       ;;
                true)     key_on=true;     key_off=false;    ;;
                false)    key_on=false;    key_off=true;     ;;
                enable)   key_on=enable;   key_off=disable;  ;;
                disable)  key_on=disable;  key_off=enable;   ;;
                enabled)  key_on=enabled;  key_off=disabled; ;;
                disabled) key_on=disabled; key_off=enabled;  ;;
                *) continue; ;;
              esac;
              echo $key_off >$sock_path;
              sleep 0.3;

              if (is_charging); then
                tmp=$key_on;
                key_on=$key_off;
                key_off=$tmp;
                echo $key_off >$sock_path;
                sleep 0.3;
              fi;

              if (! is_charging); then
                echo $key_on >$sock_path;
                sleep 0.3;
                if (is_charging); then
                  set_prop switch_$i "$sock_path $key_on $key_off";
                  if [ $i -eq 2 ]; then
                    break 3;
                  else
                    i=2;
                  fi;
                fi;
              fi;
            fi;
          done;
          if [ $i -eq 2 ]; then break 2; fi;
        fi;
      done <$cache_path;
    fi;
  done <$cache_path;
  rm $cache_path;

  if [ $i -eq 2 ]; then
    print --done;
    print --warn 'A reboot is recommended to prevent conflicts';
  else
    set_prop uevent dummyEvents;
    abort 'Failed to reconfigure';
  fi;
  return 0;
}

if [ "$1" == --force ]; then
  if ([ "$2" != --switch ] && [ "$2" != --power ]); then
    abort 'Invalid arguments';
  fi;
  enforce=true;
  shift;
else
  enforce=false;
fi;

case $1 in
  --switch)
    if [ $# -eq 2 ]; then

      is_level "$2";
      if (! $enforce); then is_belonging $2 20 85; fi;

      if [ $2 -ge 25 ]; then
        thr_enable=$(($2 - 10));
      elif [ $2 -ge 20 ]; then
        thr_enable=15;
      elif [ $2 -ge 6 ]; then
        thr_enable=$(($2 - 5));
      elif [ $2 -eq 1 ]; then
        thr_disable=2;
        thr_enable=1;
      else
        thr_enable=1;
      fi;

    elif [ $# -eq 3 ]; then

      is_level "$2";
      is_level "$3";

      if [ $2 -le $3 ]; then
        abort "$2 is not > $3";
      elif (! $enforce); then
        is_belonging $2 15 85;
        is_belonging $3 15 85;
        if [ $2 -lt $(($3 + 5)) ]; then abort "$2 is too close to $3"; fi;
      fi;

    else
      abort 'Invalid arguments';
    fi;
    set_prop thr_disable $thr_disable $2;
    set_prop thr_enable  $thr_enable  $3;
    print --done;
  ;;

  --power)
    if [ $# -ne 2 ]; then abort 'Invalid arguments'; fi;

    is_level "$2";
    if (! $enforce); then is_belonging $2 5 20; fi;

    set_prop thr_power $2;
    print --done;
  ;;

  --revert)
    if [ $# -gt 1 ]; then abort 'Invalid arguments'; fi;

    set_prop thr_disable 80;
    set_prop thr_enable  70;
    set_prop thr_power   20;
    print --done;
  ;;

  --toggle)
    shift;
    case $1 in
      --switch)
        if (! $(auto_switch)); then
          if (! is_runningd); then abort 'The mcc daemon is not running'; fi;
          reconfigure;
        fi;
        toggle auto_switch 'Auto Switch';
      ;;
      --power)
        if (! $(auto_power)); then
          if (! is_runningd); then abort 'The mcc daemon is not running'; fi;
          reconfigure;
        fi;
        toggle auto_power 'Auto Power';
      ;;
      --revert)
        if (! is_runningd); then abort 'The mcc daemon is not running'; fi;
        reconfigure;
        set_prop auto_switch true;
        set_prop auto_power  true;
        print --done;
      ;;
      *) abort 'Invalid arguments'; ;;
    esac;
  ;;

  --enable)
    if [ $# -ne 2 ]; then abort 'Invalid arguments'; fi;
    charge --enable $2;
  ;;

  --disable)
    if [ $# -ne 2 ]; then abort 'Invalid arguments'; fi;
    charge --disable $2;
  ;;

  --cleanup)
    for pid in $(ps | grep -v grep | grep '{mcc}' | grep -v $$ | awk '{ print $1 }'); do
      kill -9 $pid;
    done;
    rm -f $lock_path;
    set_prop switch_do default;
    print --done;
  ;;

  --redaemon)
    if (is_runningd); then abort 'The mcc daemon is already there'; fi;

    reconfigure;
    disable_mcc_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1;
    if (! is_runningd); then abort 'Failed to relaunch the daemon'; fi;
    print --done;
  ;;

  --launch-daemon)
    switched=false;
    revert_ext=false;
    last_stat=default;

    while (:); do
      while (! reconfigure --no-action || [ -f $lock_path ]); do
        sleep 0.1;
      done;

      if ($(auto_power)); then
        if [ $(batt_level) -le $(thr_power) ]; then
          if (! poweroff); then setprop sys.powerctl shutdown; fi;
        fi;
      fi;
      case $(switch_do) in
        default)
          if ($(auto_switch)); then
            if [ $(batt_level) -ge $(thr_disable) ]; then
              last_stat=OFF;
              switch_ OFF;

            elif [ $(batt_level) -le $(thr_enable) ]; then
              last_stat=ON;
              switch_ ON;

            elif ($revert_ext); then
              if [ $last_stat != default ]; then
                switch_ $last_stat;
                if ($switched); then revert_ext=false; fi;
              fi;
            fi;
          fi;
        ;;
        disable)
          revert_ext=true;
          switch_ OFF;
        ;;
        enable)
          revert_ext=true;
          switch_ ON;
        ;;
      esac;
      sleep 1;
    done;
  ;;

  --restat)
    dumpsys batterystats --reset >/dev/null;
    rm -f /data/system/batterystats.bin;
    print --done;
  ;;

  --reconfig) reconfigure --force; ;;

  --reset)
    disable_mcc_logs=true mcc --restat >/dev/null;
    reconfigure --force;
  ;;

  --info)
    reconfigure;

    if (! is_charging); then
      chg_stat='Not charging';
    else
      chg_stat=Charging;
    fi;
    if (! $(auto_switch)); then
      as_stat=OFF;
    else
      as_stat=ON;
    fi;
    if (! $(auto_power)); then
      ap_stat=OFF;
    else
      ap_stat=ON;
    fi;
    if (! is_runningd); then
      dm_stat='Not running';
    else
      dm_stat=Running;
    fi;

    echo -e 'Battery Information\n';

    echo "- Level : $(batt_level)";
    echo "- Health: $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))";
    echo -e "- Status: $chg_stat\n";

    echo -e 'Current Settings\n';

    echo "- Auto Switch thresholds: $(thr_disable), $(thr_enable)";
    echo "- Auto Power  threshold : $(thr_power)";
    echo "- Auto Switch status    : $as_stat";
    echo -e "- Auto Power status     : $ap_stat\n";

    echo -e "Daemon Status: $dm_stat\n";
  ;;

  --help)
    head -n 5   $help_path;
    head -n 176 $help_path | tail -n 155;
  ;;

  *)
    print --error 'No arguments given';
    disable_mcc_logs=true mcc --help;
  ;;
esac;
