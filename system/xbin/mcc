#!/system/bin/sh
# My Charging Controller
# mcc Core/Main Script
# JayminSuthar @ xda-developers

# Copyright (c) 2018 Jaymin Suthar. All rights reserved.

# This file is a part of "My Charging Controller (mcc)".

# mcc is released under the terms of the GNU GPL v3, as been
## published by the Free Software Foundation. And permission
## hereby is granted to use, modify or redistribute it maybe
## partially or entirely under GPLv3 only.

# mcc was written in a hope of being useful. And any kind of
## warranty is not provided. See GPLv3 for details.

# You should already have received a copy of GPLv3 with mcc,
## if not, see <http://www.gnu.org/licenses/>.

mcc_dir=/data/adb/mcc
log_dir=$mcc_dir/log;
bin_dir=$mcc_dir/bin;
lock_path=$mcc_dir/lock;
cfg_path=$mcc_dir/mcc.conf;
help_path=$mcc_dir/docs/README.md;

abort() {
  echo ' ';
  print --error "$1";
  exit;
}

print() {
  case "$1" in
    --error) echo "FATAL ERROR: $2"; ;;
    --warn)  echo "WARNING: $2";     ;;
    --done)  echo '- Done';          ;;
    *)       echo "INFO: $1";        ;;
  esac;
}

if (! id | grep uid=0 >/dev/null); then
  abort 'mcc requires a root shell';
elif ([ ! -d $mcc_dir ] || [ ! -x $bin_dir/awk ]); then
  abort 'There was an internal error';
elif [ -f $lock_path ]; then
  abort 'mcc execution is blocked';
fi;

if [ -z "$skip_mcc_detach" ]; then
  (skip_mcc_detach=true mcc "$@" &);
  exit;
elif [ -z "$disable_mcc_logs" ]; then
  if [ -z "$skip_mcc_errors" ]; then
    skip_mcc_errors=true exec mcc "$@" 2>$log_dir/main_err.log;
  else
    set -x 2>$log_dir/main.log;
  fi;
fi;

export PATH=$bin_dir:$PATH;

get_prop() {
  sed -n "s/^$1=//p" $(ls "$2" || echo $cfg_path);
}

set_prop() {
  sed -i "s|^$1=.*|$1=$2|" $cfg_path;
}

get_event() {
  get_prop POWER_SUPPLY_$1 $(uevent_f);
}

auto_switch() {
  get_prop auto_switch;
}

auto_power() {
  get_prop auto_power;
}

thr_disable() {
  get_prop thr_disable;
}

thr_enable() {
  get_prop thr_enable;
}

thr_power() {
  get_prop thr_power;
}

switch_do() {
  get_prop switch_do;
}

uevent_f() {
  get_prop uevent;
}

batt_level() {
  get_event CAPACITY;
}

is_charging() {
  if [ "$1" != --ck-current ]; then
    get_event STATUS | grep -q '^[Cc]harging$';
  else
    test $(get_event CURRENT_NOW) -le 0;
  fi;
}

is_runningd() {
  ps | grep -v grep | grep '{mcc}' | grep '\-\-launch\-daemon$' | grep -vq $$;
}

is_belonging() {
  if ([ $1 -lt $2 ] || [ $1 -gt $3 ]); then
    abort "$1 does not belong to $2-$3";
  fi;
}

is_number() {
  echo $1 | grep -Eq '^[0-9]+$';
}

is_bounded() {
  is_belonging $1 1 99;
}

is_level() {
  if (! is_number $1); then abort "$1 is not a number"; fi;
  is_bounded $1;
}

write_() {

  for i in 1 2; do

    sw_path="$(switch_ $i)";
    key_on=$(echo "$sw_path" | awk '{ print $2 }');
    key_off=$(echo "$sw_path" | awk '{ print $3 }');
    sw_path=$(echo "$sw_path" | awk '{ print $1 }');

    if [ -z "$key_on" ]; then break; fi;
    case $1 in
      OFF) echo $key_off >$sw_path; ;;
      ON)  echo $key_on  >$sw_path; ;;
    esac;
  done;
}

switch_() {

  if (! is_number $1); then
    case $1 in
      ON)
        inv_stat=OFF;
        test='! is_charging';
      ;;
      OFF)
        inv_stat=ON;
        test='is_charging';
      ;;
    esac;

    if (eval $test); then
      switch=true;
    elif ($switch && eval "$test --ck-current"); then
      write_ $inv_stat;
      sleep 0.3;
    else
      switch=false;
    fi;
    if ($switch); then write_ $1; fi;

  else
    get_prop switch_$1;
  fi;
}

have_daemon() {
  if (! is_runningd); then abort 'The mcc daemon is not running'; fi;
}

toggle() {
  if (! $($1)); then
    val_new=true;
    stat_new=ON;

    have_daemon;
    reconfigure;
  else
    val_new=false;
    stat_new=OFF;
  fi;
  print "Toggling $2 $stat_new...";
  set_prop $1 $val_new;
  print --done;
}

charge() {
  case $1 in
    --enable)  key_init=enable;  ;;
    --disable) key_init=disable; ;;
  esac;
  text=${key_init}d;

  have_daemon;
  if [ $(switch_do) != default ]; then
    abort 'Another task is already running';
  fi;

  reconfigure;
  if (echo $2 | grep -Eq '^[0-9]+%$'); then

    end_level=$(echo $2 | tr -d %);

    is_bounded $end_level;

    print "Keep charging $text until ${end_level}%...";
    set_prop switch_do $key_init;
    while [ $(batt_level) -ne $end_level ]; do sleep 1; done;

  elif (echo $2 | grep -Eq '^[0-9]+[smh]?$'); then

    print "Keep charging $text for $2...";
    set_prop switch_do $key_init;
    sleep $2;

  else
    abort "Invalid format: $2";
  fi;
  set_prop switch_do default;
  print --done;
}

reconfigure() {
  local cache_path=$mcc_dir/tmp.cache;

  if [ ! -f /data/adb/mcc_skip_root ]; then
    skip_root=false;
  else
    skip_root=true;
  fi;

  if [ "$1" != --force ]; then
    if ([ -f $(uevent_f) ] && [ -f $(switch_ 1 | awk '{ print $1 }') ]); then
      return 0;
    elif [ "$1" == --no-action ]; then
      return 1;
    fi;
  fi;

  print 'Reconfiguring (low level)...';

  for i in 1 2; do set_prop switch_$i dummySwitch; done;
  find /sys/devices /sys/module -type f -name uevent >$cache_path;

  i=1;
  while read -r main_events; do
    if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att' $main_events); then
      set_prop uevent $main_events;

      while read -r chg_events; do
        if (grep -Eq '^POWER_SUPPLY_NAME=.*([Bb]att|USB|usb)' $chg_events || \
            grep -Eq '^DRIVER=.*[Cc]harg(er|ing)' $chg_events); then

          for sock_path in ${chg_events%/*}/*; do
            sock_info="$(ls -l $sock_path)";
            if (echo "$sock_info" | grep -Eq '^\-[rx\-]+w[rwx\-]* '             && \
                (! $skip_root || echo "$sock_info" | grep -Eq ' system | radio ')); then

              case "$(cat $sock_path)" in
                1)        key_on=1;        key_off=0;        ;;
                0)        key_on=0;        key_off=1;        ;;
                on)       key_on=on;       key_off=off;      ;;
                off)      key_on=off;      key_off=on;       ;;
                true)     key_on=true;     key_off=false;    ;;
                false)    key_on=false;    key_off=true;     ;;
                enable)   key_on=enable;   key_off=disable;  ;;
                disable)  key_on=disable;  key_off=enable;   ;;
                enabled)  key_on=enabled;  key_off=disabled; ;;
                disabled) key_on=disabled; key_off=enabled;  ;;
                *) continue; ;;
              esac;
              echo $key_off >$sock_path;
              sleep 0.3;

              if (is_charging); then
                tmp=$key_on;
                key_on=$key_off;
                key_off=$tmp;
                echo $key_off >$sock_path;
                sleep 0.3;
              fi;

              if (! is_charging); then
                echo $key_on >$sock_path;
                sleep 0.3;
                if (is_charging); then
                  set_prop switch_$i "$sock_path $key_on $key_off";
                  if [ $i -eq 2 ]; then
                    break 3;
                  else
                    i=2;
                  fi;
                fi;
              fi;
            fi;
          done;
          if [ $i -eq 2 ]; then break 2; fi;
        fi;
      done <$cache_path;
    fi;
  done <$cache_path;

  if [ $i -eq 1 ]; then
    set_prop uevent dummyEvents;
    abort 'Failed to reconfigure';
  else
    print --done;
    print --warn 'A reboot is recommended to prevent conflicts';
  fi;
  return 0;
}

if [ "$1" == --force ]; then
  if (! echo "$2" | grep -Eq '^(--switch|--power)$'); then
    abort 'Invalid argument(s)';
  fi;
  enforce=true;
  shift;
else
  enforce=false;
fi;

case $1 in
  --switch)
    if (echo $# | grep -Eq '^(2|3)$'); then abort 'Invalid argument(s)'; fi;

    print 'Processing/setting thresholds...';
    if [ $# -eq 2 ]; then

      is_level $2;
      if (! $enforce); then is_belonging $2 20 85; fi;

      if [ $2 -ge 25 ]; then
        thr_enable=$(($2 - 10));
      elif [ $2 -ge 20 ]; then
        thr_enable=15;
      elif [ $2 -ge 6 ]; then
        thr_enable=$(($2 - 5));
      elif [ $2 -eq 1 ]; then
        thr_disable=2;
        thr_enable=1;
      else
        thr_enable=1;
      fi;

    elif [ $# -eq 3 ]; then

      is_level $2;
      is_level $3;

      if [ $2 -le $3 ]; then
        abort "$2 is not > $3";
      elif (! $enforce); then
        is_belonging $2 15 85;
        is_belonging $3 15 85;
        if [ $2 -lt $(($3 + 5)) ]; then abort "$2 is too close to $3"; fi;
      fi;
    fi;

    set_prop thr_disable $thr_disable $2;
    set_prop thr_enable  $thr_enable  $3;
    print --done;
  ;;

  --power)
    if [ $# -ne 2 ]; then abort 'Invalid argument(s)'; fi;

    print 'Processing/setting threshold...';
    is_level $2;
    if (! $enforce); then is_belonging $2 5 20; fi;

    set_prop thr_power $2;
    print --done;
  ;;

  --revert)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;

    print 'Reverting thresholds...';
    set_prop thr_disable 80;
    set_prop thr_enable  70;
    set_prop thr_power   20;
    print --done;
  ;;

  --toggle)
    shift;
    case $1 in
      --switch) toggle auto_switch 'Auto Switch'; ;;
      --power)  toggle auto_power  'Auto Power';  ;;

      --revert)
        have_daemon;
        reconfigure;
        print 'Reverting Auto Switch/Power...';
        set_prop auto_switch true;
        set_prop auto_power  true;
        print --done;
      ;;
      *) abort 'Invalid argument(s)'; ;;
    esac;
  ;;

  --enable)
    if [ $# -ne 2 ]; then abort 'Invalid argument(s)'; fi;
    charge --enable $2;
  ;;

  --disable)
    if [ $# -ne 2 ]; then abort 'Invalid argument(s)'; fi;
    charge --disable $2;
  ;;

  --cleanup)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;

    print 'Cleaning...';
    for pid in $(ps | grep -v grep | grep '{mcc}' | grep -v $$ | awk '{ print $1 }'); do
      kill -9 $pid;
    done;
    set_prop switch_do default;
    print --done;
  ;;

  --redaemon)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;
    if (is_runningd); then abort 'The mcc daemon is already there'; fi;

    reconfigure;
    print 'Launching the mcc daemon...';
    disable_mcc_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1;
    sleep 0.5;
    if (! is_runningd); then abort 'Failed to relaunch the daemon'; fi;
    print --done;
  ;;

  --launch-daemon)
    switch=true;
    revert=false;
    stat_saved=default;

    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;
    if (is_runningd); then abort 'Could you rather use [--redaemon] ??'; fi;

    while (:); do
      while (! reconfigure --no-action || [ -f $lock_path ]); do
        sleep 0.1;
      done;

      if ($(auto_power)); then
        if [ $(batt_level) -le $(thr_power) ]; then
          if (! poweroff); then setprop sys.powerctl shutdown; fi;
        fi;
      fi;
      case $(switch_do) in
        default)
          if ($(auto_switch)); then
            if [ $(batt_level) -ge $(thr_disable) ]; then
              stat_saved=OFF;
              switch_ OFF;

            elif [ $(batt_level) -le $(thr_enable) ]; then
              stat_saved=ON;
              switch_ ON;

            elif ($revert); then
              if [ $stat_saved != default ]; then
                switch_ $stat_saved;
                if (! $switch); then revert=false; fi;
              fi;
            fi;
          fi;
        ;;
        disable)
          revert=true;
          switch_ OFF;
        ;;
        enable)
          revert=true;
          switch_ ON;
        ;;
      esac;
      sleep 1;
    done;
  ;;

  --restat)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;

    print 'Resetting batterystats...';
    dumpsys batterystats --reset >/dev/null;
    rm -f /data/system/batterystats.bin;
    print --done;
  ;;

  --reconfig)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;
    reconfigure --force;
  ;;

  --reset)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;

    print 'Running [--restat] -> [--reconfig]...';
    disable_mcc_logs=true skip_mcc_detach=true mcc --restat >/dev/null;
    reconfigure --force >/dev/null;
    print --done;
  ;;

  --info)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;

    reconfigure;
    if (! is_charging); then
      chg_stat='Not charging';
    else
      chg_stat=Charging;
    fi;
    if (! $(auto_switch)); then
      as_stat=OFF;
    else
      as_stat=ON;
    fi;
    if (! $(auto_power)); then
      ap_stat=OFF;
    else
      ap_stat=ON;
    fi;
    if (! is_runningd); then
      dm_stat='Not running';
    else
      dm_stat=Running;
    fi;

    echo -e 'Battery Information\n';

    echo "- Level : $(batt_level)";
    echo "- Health: $(get_event HEALTH)";
    echo -e "- Status: $chg_stat\n";

    echo -e 'Current Settings\n';

    echo "- Auto Switch thresholds: $(thr_disable), $(thr_enable)";
    echo "- Auto Power  threshold : $(thr_power)";
    echo "- Auto Switch status    : $as_stat";
    echo -e "- Auto Power status     : $ap_stat\n";

    echo -e "Daemon Status: $dm_stat\n";
  ;;

  --help)
    if [ $# -gt 1 ]; then abort 'Invalid argument(s)'; fi;

    head -n 5   $help_path;
    head -n 181 $help_path | tail -n 160;
  ;;

  *)
    print --error 'Invalid argument(s)';
    disable_mcc_logs=true mcc --help;
  ;;
esac;
