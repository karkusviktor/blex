#!/sbin/sh
# My Charging Controller
# JayminSuthar @ xda-developers

# Copyright (c) 2018 Jaymin Suthar. All rights reserved.

# This file is a part of "My Charging Controller (mcc)".

# mcc is released under the terms of the GNU GPL v3, as been
## published by the Free Software Foundation. And permission
## hereby is granted to use, modify or redistribute it maybe
## partially or entirely under GPLv3 only.

# mcc was written in a hope of being useful. And any kind of
## warranty is not provided. See GPLv3 for details.

# You should already have received a copy of GPLv3 with mcc,
## if not, see <http://www.gnu.org/licenses/>.

out_fd=$2
boot_mode=false
system=/system
system_mode=false
adb_dir=/data/adb
tmp_dir=/dev/mcc_$$
zip_dir=$tmp_dir/zip
bb_dir=$zip_dir/bin
sys_dir=$zip_dir/system
bin_path=$bb_dir/busybox
copy_path=$zip_dir/COPYING
help_path=$zip_dir/README.md
conf_path=$zip_dir/mcc.conf

umask 022
exec 2>/dev/mcc_install.log
set -x

if echo "$(ps -A || ps)" | grep -v grep | grep zygote >/dev/null; then
  boot_mode=true
else
  mount -o bind /dev/urandom /dev/random
  fd_dir=/proc/$$/fd
  if readlink $fd_dir/$2 | grep /tmp >/dev/null; then
    for fd in $fd_dir/*; do
      if readlink $fd | grep pipe >/dev/null; then
        fd=${fd##*/}
        if ps | grep -v grep | grep " 3 $fd " >/dev/null; then
          out_fd=$fd
          break
        fi
      fi
    done
  fi
fi

ui_print() {
  if ! $boot_mode; then
    echo -e "ui_print $1\nui_print" >>/proc/self/fd/$out_fd
  else
    echo "$1"
  fi
}

abort() {
  ui_print ' '
  print --error "$1"
  cleanup --error
  exit 1
}

print() {
  case "$1" in
    --done)  ui_print '- Done'      ;;
    --error) ui_print "ERROR: $2"   ;;
    --warn)  ui_print "WARNING: $2" ;;
    --info)  ui_print "INFO: $2"    ;;
    *)       ui_print "- $1"        ;;
  esac
}

cleanup() {
  print 'Cleaning up temp'

  if test "$1" == --error; then rm -r $mcc_dir $mcc_path $init_path; fi
  if umount $mount_dir; then losetup -d $loop_path; fi
  rm -r $tmp_dir

  if ! $boot_mode; then
    for mountpoint in /data /system /vendor /dev/random; do
      umount -l $mountpoint
    done
  fi
}

is_mounted() {
  mount | grep -q " $1 "
}

mount_wrap() {
  if ! mount -t auto -o $rw /$1; then
    if ! mount -t auto -o $rw,remount /$1; then abort "Mounting /$1 failed."; fi
  fi
}

get_prop() {
  sed -n "s/^$1=//p" $2
}

set_prop() {
  sed -i "s/^$1=.*/$1=$2/" $3
}

set_perm() {
  chown $2:$3 $1
  chmod $4 $1
  if test -z "$5"; then
    chcon u:object_r:system_file:s0 $1
  else
    chcon $5 $1
  fi
}

set_perm_recursive() {
  find $1 | while read -r entry; do
    if test -d $entry; then
      set_perm $entry $2 $3 $4 $6
    else
      set_perm $entry $2 $3 $5 $6
    fi
  done
}

restore_cfg() {
  if cfg_path_bak=$(ls $tmp_dir/mcc.conf); then
    print 'Migrating configs backup'
    for prop in auto_switch auto_power thr_disable thr_enable thr_power; do
      set_prop $prop $(get_prop $prop $cfg_path_bak) $cfg_path
    done
  fi
}

ui_print ' '
ui_print '************************************************************'
ui_print '                My Charging Controller (mcc)                '
ui_print '************************************************************'
ui_print '   Copyright (c) 2018 Jaymin Suthar. All rights reserved.   '
ui_print '************************************************************'
ui_print ' '

print 'Building common environment'

mkdir -p $zip_dir
unzip -o "$3" -d $zip_dir >/dev/null
if ! chmod 0755 $bin_path; then
  abort 'Unzipping files failed.'
elif ! $bin_path --install $bb_dir/; then
  abort 'Chipset is not supported.'
fi
export PATH=$bb_dir:$PATH

print 'Checking for systemless support'
if ! is_mounted /data; then
  if ! mount /data; then abort 'Mounting /data failed.'; fi
fi
if test -d $adb_dir/magisk; then
  rw=ro
else
  rw=rw
  system_mode=true

  ui_print ' '
  ui_print '************************************************************'
  ui_print '         Systemless interface (Magisk) not detected         '
  ui_print '************************************************************'
  ui_print '        mcc will install in system mode, mount rw :(        '
  ui_print '************************************************************'
  ui_print ' '
fi

print 'Mounting required partitions'
mount_wrap system
if test -f /system/init.rc; then system=/system/system; fi
if test -L $system/vendor; then mount_wrap vendor; fi

if ! $boot_mode; then
  if uname -m | grep -q arm64; then
    export LD_LIBRARY_PATH=$system/lib64:$system/vendor/lib64
  else
    export LD_LIBRARY_PATH=$system/lib:$system/vendor/lib
  fi
fi

if $system_mode; then
  mcc_dir=$adb_dir/mcc
  bin_dir=$mcc_dir/bin
  doc_dir=$mcc_dir/docs
  init_dir=$system/etc/init.d
  bb_path=$bin_dir/busybox
  cfg_path=$mcc_dir/mcc.conf
  mcc_path=$system/xbin/mcc
  init_path=$init_dir/mcc_launcher

  if test ! -d $init_dir; then
    print --info 'Your device lacks init.d support, I recommend that you'
    print --info 'try out Init.d Injector by @Zackptg5. This tool can be'
    print --info 'found at XDA, search the forums :)'
    abort 'init.d support not detected.'
  fi

  print --info 'Install started (system).'

  print 'Initializing files and paths'
  mv $cfg_path $tmp_dir/
  rm -r $mcc_dir
  mkdir -p $doc_dir $bin_dir $mcc_dir/log

  print 'Copying files to destinations'
  cp -rf $sys_dir/.            $system/
  cp     $bin_path             $bin_dir/
  cp     $conf_path            $mcc_dir/
  cp     $copy_path $help_path $doc_dir/

  restore_cfg

  print 'Setting permissions of files'
  set_perm_recursive $mcc_dir   0 0    0700 0600 u:object_r:adb_data_file:s0
  set_perm           $bb_path   0 2000 0710      u:object_r:adb_data_file:s0
  set_perm           $mcc_path  0 2000 0755
  set_perm           $init_path 0 0    0755

  print 'Giving a final touch'
  $bb_path --install $bin_dir/

else
  mount_dir=$tmp_dir/img
  mcc_dir=$mount_dir/mcc
  bin_dir=$mcc_dir/bin
  doc_dir=$mcc_dir/docs
  xbin_dir=$mcc_dir/system/xbin
  bb_path=$bin_dir/busybox
  cfg_path=$mcc_dir/mcc.conf
  img_path=$adb_dir/magisk.img
  mcc_dir_live=/sbin/.core/img/mcc

  if $boot_mode; then img_path=$adb_dir/magisk_merge.img; fi
  if test ! -d $system/xbin; then xbin_dir=${xbin_dir%/*}/bin; fi

  if test ! -f $img_path; then
    print "Creating a 64M $img_path"
    if ! make_ext4fs -l 64M $img_path >/dev/null; then
      $system/bin/mke2fs -t ext4 $img_path 64M >/dev/null
    fi
  fi

  mkdir $mount_dir
  print "Mounting $img_path to $mount_dir"
  for minor in 0 1 2 3 4 5 6 7; do
    loop_path=/dev/block/loop$minor

    if test ! -b $loop_path; then mknod $loop_path b 7 $minor; fi
    if losetup $loop_path $img_path >/dev/null; then
      if mount -t ext4 -o loop $loop_path $mount_dir; then break; fi
    fi
  done
  if ! is_mounted $mount_dir; then abort 'Mounting image failed.'; fi

  print --info 'Install started (systemless).'

  print 'Initializing files and paths'
  if $boot_mode; then
    cp $mcc_dir_live/mcc.conf $tmp_dir/
  else
    cp $cfg_path $tmp_dir/
  fi
  rm -r $mcc_dir
  mkdir -p $doc_dir $xbin_dir $bin_dir $mcc_dir/log

  print 'Copying files to destinations'
  cp -r $sys_dir/xbin/.                                          $xbin_dir/
  cp    $bin_path                                                $bin_dir/
  cp    $conf_path $zip_dir/post-fs-data.sh $zip_dir/module.prop $mcc_dir/
  cp    $copy_path $help_path                                    $doc_dir/

  restore_cfg

  print 'Setting permissions of files'
  set_perm_recursive $mcc_dir  0 0    0755 0644
  set_perm_recursive $xbin_dir 0 2000 0755 0755
  set_perm           $bb_path  0 2000 0755

  print 'Giving a final touch'
  touch $mcc_dir/auto_mount
  if $boot_mode; then
    mkdir $mcc_dir_live
    touch $mcc_dir_live/update
    cp -f $mcc_dir/module.prop $mcc_dir_live/
  fi
  $bb_path --install $bin_dir/
fi

cleanup
print --warn 'mcc is installed! After rebooting, please configure'
print --warn 'it by calling the configurator with `mcc --config`.'
print --warn 'Otherwise, mcc will not work!'
print --done
exit 0
